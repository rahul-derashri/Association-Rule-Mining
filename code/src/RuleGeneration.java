import java.util.ArrayList;


/**
 * @author RahulDerashri
 * This class process the Frequent Item-sets generated to produce rules satisfying the minimum confidence.
 *
 */
public class RuleGeneration {
	
	ArrayList<ArrayList<String>> input;
	
	public ArrayList<Rule> rules;
	
	public RuleGeneration(ArrayList<ArrayList<String>> input) {
		this.input = input;
		rules = new ArrayList<Rule>();
	}
	
	public ArrayList<Rule> getRules() {
		return rules;
	}

	public void setRules(ArrayList<Rule> rules) {
		this.rules = rules;
	}
	
	
	
	/**
	 * This method takes candidates one by one, generate subsets and then call generateRules() 
	 * to create rules based on subsets. 
	 * 
	 * @param freqItemSets: Candidates generated by Apriori algorithm
	 */
	public void processSets(ArrayList<ArrayList<String>> freqItemSets){
		ArrayList<ArrayList<String>> subsets = null;
		for(ArrayList<String> set: freqItemSets){
			 subsets = getSubsets(set, 0);
			 for( ArrayList<String> subset : subsets ){
				 if( subset.size() > 0 && subset.size() < set.size() )
					 this.generateRules(subset , set);
			 }
		}
	}
	
	/**
	 * This method generate subsets from the candidate sets
	 * (A,B,C) --> (A), (B), (C), (A,B), (B,C), (A,C)
	 * 
	 * @param set: Subsets generated from candidate set
	 * @param index: always '0' at the start
	 * @return
	 */
	public ArrayList<ArrayList<String>> getSubsets(ArrayList<String> set , int index){
		ArrayList<ArrayList<String>> allsubsets;
		if( set.size() == index ){
			allsubsets = new ArrayList<ArrayList<String>>();
			ArrayList<String> subset = new ArrayList<String>(); // Empty subset
			allsubsets.add(subset);
		}
		else{
			allsubsets = getSubsets(set, index+1);
			ArrayList<ArrayList<String>> moresubsets = new ArrayList<ArrayList<String>>();
			String item = set.get(index);
			for( ArrayList<String> subset : allsubsets ){
				ArrayList<String> newsubset = new ArrayList<String>();
				newsubset.addAll(subset);
				newsubset.add(item);
				moresubsets.add(newsubset);
			}
			allsubsets.addAll(moresubsets);
		}
		
		return allsubsets;
	}
	
	
	/**
	 * This method generates Rule by setting the subset as BODY and the rest of the elements from the
	 * candidate as HEAD
	 * 
	 * @param body: BODY of the Rule
	 * @param itemSet: Candidate Set
	 */
	public void generateRules(ArrayList<String> body, ArrayList<String> itemSet){
		ArrayList<String> head = new ArrayList<String>();
		for(String str : itemSet){
			if( !body.contains(str) )
				head.add(str);
		}
		
		if( isConfidenceSat(body , head) ){
			rules.add(new Rule(body,body.size(), head , head.size()));
		}
	}
	
	
	
	/**
	 * This method calculates confidence for the rule and return true if confidence is 
	 * above MIN_CONFIDENCE false otherwise 
	 * 
	 * @param body: BODY of the Rule
	 * @param head: HEAD of the Rule
	 * @return true if confidence is above MIN_CONFIDENCE false otherwise.
	 */
	public boolean isConfidenceSat(ArrayList<String> body, ArrayList<String> head){
		int nume = 0;
		int deno = 0;
		boolean flag = true;
		for( ArrayList<String> sample : input ){
			flag = true;
			for( String str : body ){
				int index = Integer.parseInt(str.split("_")[1]);
				if( !sample.get(index-1).equalsIgnoreCase(str) ){
					flag = false;
					break;
				}
			}
			
			if( flag ){
				deno++;
				for( String str : head ){
					int index = Integer.parseInt(str.split("_")[1]);
					if( !sample.get(index-1).equalsIgnoreCase(str) ){
						flag = false;
						break;
					}
				}
				if( flag ){
					nume++;
				}
			}
		}
		
		if( deno > 0 && ((nume*100.00)/deno) >= Implement.MIN_CONFIDENCE ){
			return true;
		}
		
		return false;
		
	}
}
